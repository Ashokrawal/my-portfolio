{
  "version": 3,
  "sources": ["../../lamina/vanilla.js"],
  "sourcesContent": ["import { MathUtils, Color, Vector3, ShaderMaterial } from 'three';\n\nconst BlendModes = {\n  normal: 1,\n  add: 2,\n  subtract: 3,\n  multiply: 4,\n  addsub: 5,\n  lighten: 6,\n  darken: 7,\n  switch: 8,\n  divide: 9,\n  overlay: 10,\n  screen: 11,\n  softlight: 12\n};\nconst NoiseTypes = {\n  white: 1,\n  perlin: 2,\n  simplex: 3\n};\nconst MappingTypes = {\n  uv: 1,\n  local: 2,\n  world: 3\n};\n\nclass Abstract {\n  static genID() {\n    return MathUtils.generateUUID().replaceAll('-', '_');\n  }\n\n  getBlendMode(type, a, b) {\n    if (type === BlendModes['normal']) return `sc_copy(${a}, ${b})`;else if (type === BlendModes['add']) return `sc_add(${a}, ${b})`;else if (type === BlendModes['subtract']) return `sc_subtract(${a}, ${b})`;else if (type === BlendModes['multiply']) return `sc_multiply(${a}, ${b})`;else if (type === BlendModes['addsub']) return `sc_addSub(${a}, ${b})`;else if (type === BlendModes['lighten']) return `sc_lighten(${a}, ${b})`;else if (type === BlendModes['darken']) return `sc_darken(${a}, ${b})`;else if (type === BlendModes['divide']) return `sc_divide(${a}, ${b})`;else if (type === BlendModes['overlay']) return `sc_overlay(${a}, ${b})`;else if (type === BlendModes['screen']) return `sc_screen(${a}, ${b})`;else if (type === BlendModes['softlight']) return `sc_softLight(${a}, ${b})`;else if (type === BlendModes['switch']) return `sc_switch(${a}, ${b})`;\n  }\n\n  getVertexVariables() {\n    return '';\n  }\n\n  getVertexBody(e) {\n    return '';\n  }\n\n}\n\nclass Base extends Abstract {\n  constructor(props) {\n    super();\n    this.name = 'Base';\n    this.mode = 'normal';\n    this.uuid = Abstract.genID();\n    const {\n      color,\n      alpha,\n      mode\n    } = props || {};\n    this.uniforms = {\n      [`u_${this.uuid}_color`]: {\n        value: new Color(color != null ? color : '#ffffff')\n      },\n      [`u_${this.uuid}_alpha`]: {\n        value: alpha != null ? alpha : 1\n      }\n    };\n    this.mode = mode || 'normal';\n  }\n\n  getFragmentVariables() {\n    return `    \n    uniform float u_${this.uuid}_alpha;\n    uniform vec3 u_${this.uuid}_color;\n`;\n  }\n\n  getFragmentBody(e) {\n    return `    \n      ${e} = ${this.getBlendMode(BlendModes[this.mode], e, `vec4(u_${this.uuid}_color, u_${this.uuid}_alpha)`)};\n  `;\n  }\n\n  set color(v) {\n    this.uniforms[`u_${this.uuid}_color`].value = new Color(v);\n  }\n\n  get color() {\n    return this.uniforms[`u_${this.uuid}_color`].value;\n  }\n\n  set alpha(v) {\n    this.uniforms[`u_${this.uuid}_alpha`].value = v;\n  }\n\n  get alpha() {\n    return this.uniforms[`u_${this.uuid}_alpha`].value;\n  }\n\n}\n\nclass Depth extends Abstract {\n  constructor(props) {\n    super();\n    this.name = 'Depth';\n    this.mode = 'normal';\n    this.uuid = Abstract.genID();\n    const {\n      alpha,\n      mode,\n      colorA,\n      colorB,\n      near,\n      far,\n      origin,\n      isVector\n    } = props || {};\n    this.uniforms = {\n      [`u_${this.uuid}_alpha`]: {\n        value: alpha != null ? alpha : 1\n      },\n      [`u_${this.uuid}_near`]: {\n        value: near != null ? near : 700\n      },\n      [`u_${this.uuid}_far`]: {\n        value: far != null ? far : 1e7\n      },\n      [`u_${this.uuid}_origin`]: {\n        value: origin != null ? origin : new Vector3(0, 0, 0)\n      },\n      [`u_${this.uuid}_colorA`]: {\n        value: new Color(colorA != null ? colorA : '#ffffff')\n      },\n      [`u_${this.uuid}_colorB`]: {\n        value: new Color(colorB != null ? colorB : '#ffffff')\n      },\n      [`u_${this.uuid}_isVector`]: {\n        value: isVector != null ? isVector : true\n      }\n    };\n    this.mode = mode || 'normal';\n  }\n\n  getVertexVariables() {\n    return (\n      /* glsl */\n      `\n    varying vec3 v_${this.uuid}_worldPosition;\n    `\n    );\n  }\n\n  getVertexBody(e) {\n    return (\n      /* glsl */\n      `\n    v_${this.uuid}_worldPosition = vec3(vec4(position, 1.0) * modelMatrix);\n    `\n    );\n  }\n\n  getFragmentVariables() {\n    return (\n      /* glsl */\n      `    \n    uniform float u_${this.uuid}_alpha;\n    uniform float u_${this.uuid}_near;\n    uniform float u_${this.uuid}_far;\n    uniform float u_${this.uuid}_isVector;\n    uniform vec3 u_${this.uuid}_origin;\n    uniform vec3 u_${this.uuid}_colorA;\n    uniform vec3 u_${this.uuid}_colorB;\n\n    varying vec3 v_${this.uuid}_worldPosition;\n`\n    );\n  }\n\n  getFragmentBody(e) {\n    return (\n      /* glsl */\n      `    \n     \n      vec3 f_${this.uuid}_base = ( u_${this.uuid}_isVector > 0.5 ) ?  u_${this.uuid}_origin : cameraPosition;\n      float f_${this.uuid}_dist = length( v_${this.uuid}_worldPosition.xyz - f_${this.uuid}_base );\n      float f_${this.uuid}_dep = ( f_${this.uuid}_dist - u_${this.uuid}_near ) / ( u_${this.uuid}_far - u_${this.uuid}_near );\n\n      vec3 f_${this.uuid}_depth =  mix( u_${this.uuid}_colorB, u_${this.uuid}_colorA, 1.0 - clamp( f_${this.uuid}_dep, 0., 1. ) );\n\n      ${e} = ${this.getBlendMode(BlendModes[this.mode], e, `vec4(f_${this.uuid}_depth, u_${this.uuid}_alpha)`)};\n  `\n    );\n  }\n\n  set alpha(v) {\n    this.uniforms[`u_${this.uuid}_alpha`].value = v;\n  }\n\n  get alpha() {\n    return this.uniforms[`u_${this.uuid}_alpha`].value;\n  }\n\n  set near(v) {\n    this.uniforms[`u_${this.uuid}_near`].value = v;\n  }\n\n  get near() {\n    return this.uniforms[`u_${this.uuid}_near`].value;\n  }\n\n  set far(v) {\n    this.uniforms[`u_${this.uuid}_far`].value = v;\n  }\n\n  get far() {\n    return this.uniforms[`u_${this.uuid}_far`].value;\n  }\n\n  set origin(v) {\n    this.uniforms[`u_${this.uuid}_origin`].value = v;\n  }\n\n  get origin() {\n    return this.uniforms[`u_${this.uuid}_origin`].value;\n  }\n\n  set colorA(v) {\n    this.uniforms[`u_${this.uuid}_colorA`].value = new Color(v);\n  }\n\n  get colorA() {\n    return this.uniforms[`u_${this.uuid}_colorA`].value;\n  }\n\n  set colorB(v) {\n    this.uniforms[`u_${this.uuid}_colorB`].value = new Color(v);\n  }\n\n  get colorB() {\n    return this.uniforms[`u_${this.uuid}_colorB`].value;\n  }\n\n  set isVector(v) {\n    this.uniforms[`u_${this.uuid}_isVector`].value = v;\n  }\n\n  get isVector() {\n    return this.uniforms[`u_${this.uuid}_isVector`].value;\n  }\n\n}\n\nclass Fresnel extends Abstract {\n  constructor(props) {\n    super();\n    this.name = 'Fresnel';\n    this.mode = 'normal';\n    this.uuid = Abstract.genID();\n    const {\n      alpha,\n      mode,\n      color,\n      bias,\n      intensity,\n      power\n    } = props || {};\n    this.uniforms = {\n      [`u_${this.uuid}_alpha`]: {\n        value: alpha != null ? alpha : 1\n      },\n      [`u_${this.uuid}_color`]: {\n        value: new Color(color != null ? color : '#ffffff')\n      },\n      [`u_${this.uuid}_bias`]: {\n        value: bias != null ? bias : 0\n      },\n      [`u_${this.uuid}_intensity`]: {\n        value: intensity != null ? intensity : 1\n      },\n      [`u_${this.uuid}_power`]: {\n        value: power != null ? power : 2\n      }\n    };\n    this.mode = mode || 'normal';\n  }\n\n  getVertexVariables() {\n    return (\n      /* glsl */\n      `\n    varying vec3 v_${this.uuid}_worldPosition;\n    varying vec3 v_${this.uuid}_worldNormal;\n    `\n    );\n  }\n\n  getVertexBody(e) {\n    return (\n      /* glsl */\n      `\n    v_${this.uuid}_worldPosition = normalize(vec3(modelViewMatrix * vec4(position, 1.0)).xyz);\n    v_${this.uuid}_worldNormal = normalize(normalMatrix * normal);\n    `\n    );\n  }\n\n  getFragmentVariables() {\n    return (\n      /* glsl */\n      `    \n    uniform float u_${this.uuid}_alpha;\n    uniform vec3 u_${this.uuid}_color;\n    uniform float u_${this.uuid}_bias;\n    uniform float u_${this.uuid}_intensity;\n    uniform float u_${this.uuid}_power;\n    uniform float u_${this.uuid}_factor;\n\n    varying vec3 v_${this.uuid}_worldPosition;\n    varying vec3 v_${this.uuid}_worldNormal;\n`\n    );\n  }\n\n  getFragmentBody(e) {\n    return (\n      /* glsl */\n      `    \n      float f_${this.uuid}_a = ( 1.0 - -min(dot(v_${this.uuid}_worldPosition, normalize(v_${this.uuid}_worldNormal) ), 0.0) );\n      float f_${this.uuid}_fresnel = u_${this.uuid}_bias + (u_${this.uuid}_intensity * pow(f_${this.uuid}_a, u_${this.uuid}_power));\n\n      ${e} = ${this.getBlendMode(BlendModes[this.mode], e, `vec4(u_${this.uuid}_color * f_${this.uuid}_fresnel, u_${this.uuid}_alpha)`)};\n  `\n    );\n  }\n\n  set alpha(v) {\n    this.uniforms[`u_${this.uuid}_alpha`].value = v;\n  }\n\n  get alpha() {\n    return this.uniforms[`u_${this.uuid}_alpha`].value;\n  }\n\n  set color(v) {\n    this.uniforms[`u_${this.uuid}_color`].value = new Color(v);\n  }\n\n  get color() {\n    return this.uniforms[`u_${this.uuid}_color`].value;\n  }\n\n  set bias(v) {\n    this.uniforms[`u_${this.uuid}_bias`].value = v;\n  }\n\n  get bias() {\n    return this.uniforms[`u_${this.uuid}_bias`].value;\n  }\n\n  set intensity(v) {\n    this.uniforms[`u_${this.uuid}_intensity`].value = v;\n  }\n\n  get intensity() {\n    return this.uniforms[`u_${this.uuid}_intensity`].value;\n  }\n\n  set power(v) {\n    this.uniforms[`u_${this.uuid}_power`].value = v;\n  }\n\n  get power() {\n    return this.uniforms[`u_${this.uuid}_power`].value;\n  }\n\n}\n\nclass Noise extends Abstract {\n  constructor(props) {\n    super();\n    this.name = 'Noise';\n    this.mode = 'normal';\n    this.type = 'perlin';\n    this.mapping = 'uv';\n    this.uuid = Abstract.genID();\n    const {\n      alpha,\n      mode,\n      scale,\n      colorA,\n      colorB,\n      type,\n      mapping\n    } = props || {};\n    this.uniforms = {\n      [`u_${this.uuid}_alpha`]: {\n        value: alpha != null ? alpha : 1\n      },\n      [`u_${this.uuid}_scale`]: {\n        value: scale != null ? scale : 1\n      },\n      [`u_${this.uuid}_colorA`]: {\n        value: new Color(colorA != null ? colorA : '#ffffff')\n      },\n      [`u_${this.uuid}_colorB`]: {\n        value: new Color(colorB != null ? colorB : '#000000')\n      }\n    };\n    this.mode = mode || 'normal';\n    this.type = type || 'perlin';\n    this.mapping = mapping || 'uv';\n  }\n\n  getMapping() {\n    switch (MappingTypes[this.mapping]) {\n      case MappingTypes.uv:\n        return `vec3(uv, 0.)`;\n\n      case MappingTypes.local:\n        return `position`;\n\n      case MappingTypes.world:\n        return `\n        (modelMatrix * vec4(position,1.0)).xyz;\n        `;\n    }\n  }\n\n  getNoise(e) {\n    switch (NoiseTypes[this.type]) {\n      case NoiseTypes.white:\n        return `lamina_noise_white(${e})`;\n\n      case NoiseTypes.perlin:\n        return `lamina_noise_perlin(${e})`;\n\n      case NoiseTypes.simplex:\n        return `lamina_noise_simplex(${e})`;\n    }\n  }\n\n  getVertexVariables() {\n    return (\n      /* glsl */\n      `\n    varying vec3 v_${this.uuid}_position;\n    `\n    );\n  }\n\n  getVertexBody(e) {\n    return (\n      /* glsl */\n      `\n    v_${this.uuid}_position = ${this.getMapping()};\n    `\n    );\n  }\n\n  getFragmentVariables() {\n    return (\n      /* glsl */\n      `    \n    uniform float u_${this.uuid}_alpha;\n    uniform vec3 u_${this.uuid}_colorA;\n    uniform vec3 u_${this.uuid}_colorB;\n    uniform float u_${this.uuid}_scale;\n    varying vec3 v_${this.uuid}_position;\n`\n    );\n  }\n\n  getFragmentBody(e) {\n    return (\n      /* glsl */\n      `    \n      float f_${this.uuid}_noise = ${this.getNoise(`v_${this.uuid}_position * u_${this.uuid}_scale`)};\n      vec3 f_${this.uuid}_noiseColor = mix(u_${this.uuid}_colorA, u_${this.uuid}_colorB, f_${this.uuid}_noise);\n\n      ${e} = ${this.getBlendMode(BlendModes[this.mode], e, `vec4(f_${this.uuid}_noiseColor, u_${this.uuid}_alpha)`)};\n  `\n    );\n  }\n\n  set alpha(v) {\n    this.uniforms[`u_${this.uuid}_alpha`].value = v;\n  }\n\n  get alpha() {\n    return this.uniforms[`u_${this.uuid}_alpha`].value;\n  }\n\n  set colorA(v) {\n    this.uniforms[`u_${this.uuid}_colorA`].value = new Color(v);\n  }\n\n  get colorA() {\n    return this.uniforms[`u_${this.uuid}_colorA`].value;\n  }\n\n  set colorB(v) {\n    this.uniforms[`u_${this.uuid}_colorB`].value = new Color(v);\n  }\n\n  get colorB() {\n    return this.uniforms[`u_${this.uuid}_colorB`].value;\n  }\n\n  set scale(v) {\n    this.uniforms[`u_${this.uuid}_scale`].value = v;\n  }\n\n  get scale() {\n    return this.uniforms[`u_${this.uuid}_scale`].value;\n  }\n\n}\n\nclass Normals extends Abstract {\n  constructor(props) {\n    super();\n    this.name = 'Normals';\n    this.mode = 'normal';\n    this.uuid = Abstract.genID();\n    const {\n      alpha,\n      mode,\n      direction\n    } = props || {};\n    this.uniforms = {\n      [`u_${this.uuid}_alpha`]: {\n        value: alpha != null ? alpha : 1\n      },\n      [`u_${this.uuid}_direction`]: {\n        value: direction\n      }\n    };\n    this.mode = mode || 'normal';\n  }\n\n  getVertexVariables() {\n    return (\n      /* glsl */\n      `\n    varying vec3 v_${this.uuid}_normals;\n    `\n    );\n  }\n\n  getVertexBody(e) {\n    return (\n      /* glsl */\n      `\n    v_${this.uuid}_normals = normal;\n    `\n    );\n  }\n\n  getFragmentVariables() {\n    return (\n      /* glsl */\n      `    \n    uniform float u_${this.uuid}_alpha;\n    uniform vec3 u_${this.uuid}_color;\n    uniform vec3 u_${this.uuid}_direction;\n\n    varying vec3 v_${this.uuid}_normals;\n`\n    );\n  }\n\n  getFragmentBody(e) {\n    return (\n      /* glsl */\n      `    \n      vec3 f_${this.uuid}_normalColor = vec3(1.);\n      f_${this.uuid}_normalColor.x = v_${this.uuid}_normals.x * u_${this.uuid}_direction.x;\n      f_${this.uuid}_normalColor.y = v_${this.uuid}_normals.y * u_${this.uuid}_direction.y;\n      f_${this.uuid}_normalColor.z = v_${this.uuid}_normals.z * u_${this.uuid}_direction.z;\n\n      ${e} = ${this.getBlendMode(BlendModes[this.mode], e, `vec4(f_${this.uuid}_normalColor, u_${this.uuid}_alpha)`)};\n  `\n    );\n  }\n\n  set alpha(v) {\n    this.uniforms[`u_${this.uuid}_alpha`].value = v;\n  }\n\n  get alpha() {\n    return this.uniforms[`u_${this.uuid}_alpha`].value;\n  }\n\n  set color(v) {\n    this.uniforms[`u_${this.uuid}_color`].value = new Color(v);\n  }\n\n  get color() {\n    return this.uniforms[`u_${this.uuid}_color`].value;\n  }\n\n  set direction(v) {\n    this.uniforms[`u_${this.uuid}_direction`].value = v;\n  }\n\n  get direction() {\n    return this.uniforms[`u_${this.uuid}_direction`].value;\n  }\n\n}\n\nclass Texture extends Abstract {\n  constructor(props) {\n    super();\n    this.name = 'Texture';\n    this.mode = 'texture';\n    this.uuid = Abstract.genID();\n    const {\n      alpha,\n      mode,\n      map\n    } = props || {};\n    this.uniforms = {\n      [`u_${this.uuid}_alpha`]: {\n        value: alpha != null ? alpha : 1\n      },\n      [`u_${this.uuid}_map`]: {\n        value: map\n      }\n    };\n    this.mode = mode || 'normal';\n  }\n\n  getVertexVariables() {\n    return (\n      /* glsl */\n      `\n    varying vec2 v_${this.uuid}_uv;\n    `\n    );\n  }\n\n  getVertexBody(e) {\n    return (\n      /* glsl */\n      `\n    v_${this.uuid}_uv = uv;\n    `\n    );\n  }\n\n  getFragmentVariables() {\n    return (\n      /* glsl */\n      `    \n    uniform float u_${this.uuid}_alpha;\n    uniform sampler2D u_${this.uuid}_map;\n\n    varying vec2 v_${this.uuid}_uv;\n`\n    );\n  }\n\n  getFragmentBody(e) {\n    return (\n      /* glsl */\n      `    \n      vec4 f_${this.uuid}_texture = texture2D(u_${this.uuid}_map, v_${this.uuid}_uv);\n\n      ${e} = ${this.getBlendMode(BlendModes[this.mode], e, `vec4(f_${this.uuid}_texture.xyz, f_${this.uuid}_texture.a * u_${this.uuid}_alpha)`)};\n  `\n    );\n  }\n\n  set alpha(v) {\n    this.uniforms[`u_${this.uuid}_alpha`].value = v;\n  }\n\n  get alpha() {\n    return this.uniforms[`u_${this.uuid}_alpha`].value;\n  }\n\n  set map(v) {\n    this.uniforms[`u_${this.uuid}_map`].value = v;\n  }\n\n  get map() {\n    return this.uniforms[`u_${this.uuid}_map`].value;\n  }\n\n}\n\nvar HelperChunk = /* glsl */\n`\n\nfloat lamina_map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat lamina_normalize(float v) { return lamina_map(v, -1.0, 1.0, 0.0, 1.0); }\n`;\n\nvar BlendModesChunk = /* glsl */\n`\n// SC: Blend modes definitions **********\n\nfloat sc_softLight(float f, float b) {\n  return (f < 0.5)\n             ? b - (1.0 - 2.0 * f) * b * (1.0 - b)\n             : (b < 0.25)\n                   ? b + (2.0 * f - 1.0) * b * ((16.0 * b - 12.0) * b + 3.0)\n                   : b + (2.0 * f - 1.0) * (sqrt(b) - b);\n}\n\nvec4 sc_softLight(vec4 b, vec4 f) {\n  vec4 result;\n  result.x = sc_softLight(f.x, b.x);\n  result.y = sc_softLight(f.y, b.y);\n  result.z = sc_softLight(f.z, b.z);\n  result.a = sc_softLight(f.a, b.a);\n  \n  return result;\n}\n\nvec4 sc_screen(vec4 f, vec4 b) {\n  vec4 result;\n\n  result = 1.0 - (1.0 - f) * (1.0 - b);\n  result = mix(f, result, b.a);\n\n  return result;\n}\n\nfloat sc_overlay(float f, float b) {\n  return (b < 0.5) ? 2.0 * f * b : 1.0 - 2.0 * (1.0 - f) * (1.0 - b);\n}\n\nvec4 sc_overlay(vec4 b, vec4 f) {\n  vec4 result;\n  result.x = sc_overlay(f.x, b.x);\n  result.y = sc_overlay(f.y, b.y);\n  result.z = sc_overlay(f.z, b.z);\n  result.a = sc_overlay(f.a, b.a);\n\n\n  return result;\n}\n\nvec4 sc_divide(vec4 f, vec4 b) {\n  vec4 result = vec4(0.0);\n  result = b / f;\n  return result;\n}\n\nvec4 sc_switch(vec4 f, vec4 b) {\n  vec4 result = vec4(0.0);\n  result = max((f * b.a), (b * (1.0 - b.a)));\n  return result;\n}\n\nvec4 sc_darken(vec4 f, vec4 b) {\n  vec4 result = vec4(0.0);\n  result = mix(f, min(f, b), b.a);\n  return result;\n}\n\nvec4 sc_lighten(vec4 f, vec4 b) {\n  vec4 result = vec4(0.0);\n  result = mix(f, max(f, b), b.a);\n  return result;\n}\n\nfloat sc_addSub(float f, float b) {\n  return f > 0.5 ? f + b : b - f;\n}\nvec4 sc_addSub(vec4 f, vec4 b) {\n  vec4 result = vec4(0.0);\n\n  result.r = sc_addSub(f.r, b.r * b.a);\n  result.g = sc_addSub(f.g, b.g * b.a);\n  result.b = sc_addSub(f.b, b.b* b.a ) ;\n  result.a = sc_addSub(f.a, b.a);\n\n  return result;\n}\n\nvec4 sc_multiply(vec4 f, vec4 b) {\n  vec4 result = vec4(0.0);\n\n  result = mix(f, b * f, b.a);\n  result.a = f.a + b.a * (1.0 - f.a);\n\n  return result;\n}\n\nvec4 sc_subtract(vec4 f, vec4 b) {\n  vec4 result = vec4(0.0);\n\n  result = f - b * b.a;\n  result.a = f.a + b.a * (1.0 - f.a);\n\n  return result;\n}\n\nvec4 sc_add(vec4 f, vec4 b) {\n  vec4 result = vec4(0.0);\n\n  result = f + b * (b.a);\n  result.a = f.a + b.a * (1.0 - f.a);\n\n  return result;\n}\n\nvec4 sc_copy(vec4 b, vec4 f) {\n  vec4 result = vec4(0.0);\n\n  result.a = f.a + b.a * (1.0 - f.a);\n  result.rgb = ((f.rgb * f.a) + (b.rgb * b.a) * (1.0 - f.a));\n\n  return result;\n}\n\n`; // ************************************\n\nvar NoiseChunk = /* glsl */\n`\n\n// From: https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n// Huge thanks to the creators of these algorithms\n\nfloat lamina_noise_mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 lamina_noise_mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 lamina_noise_perm(vec4 x){return lamina_noise_mod289(((x * 34.0) + 1.0) * x);}\nvec4 lamina_noise_permute(vec4 x) { return mod(((x * 34.0) + 1.0) * x, 289.0); }\nvec4 lamina_noise_taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\n\nfloat lamina_noise_white(vec2 p) {\n  return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) *\n               (0.1 + abs(sin(p.y * 13.0 + p.x))));\n}\n\nfloat lamina_noise_white(vec3 p) {\n  return lamina_noise_white(p.xy);\n}\n\n\nvec3 lamina_noise_fade(vec3 t) { return t * t * t * (t * (t * 6.0 - 15.0) + 10.0); }\n\nfloat lamina_noise_perlin(vec3 P) {\n  vec3 Pi0 = floor(P);        // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P);        // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = lamina_noise_permute(lamina_noise_permute(ix) + iy);\n  vec4 ixy0 = lamina_noise_permute(ixy + iz0);\n  vec4 ixy1 = lamina_noise_permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);\n  vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);\n  vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);\n  vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);\n  vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);\n  vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);\n  vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);\n  vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);\n\n  vec4 norm0 = lamina_noise_taylorInvSqrt(\n      vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = lamina_noise_taylorInvSqrt(\n      vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = lamina_noise_fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111),\n                 fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return lamina_normalize(2.2 * n_xyz);\n}\n\nfloat lamina_noise_simplex(vec3 v) {\n  const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  // First corner\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  // Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  //  x0 = x0 - 0. + 0.0 * C\n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n  // Permutations\n  i = mod(i, 289.0);\n  vec4 p = lamina_noise_permute(lamina_noise_permute(lamina_noise_permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y +\n                             vec4(0.0, i1.y, i2.y, 1.0)) +\n                    i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  // Gradients\n  // ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0 / 7.0; // N=7\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z); //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_); // mod(j,N)\n\n  vec4 x = x_ * ns.x + ns.yyyy;\n  vec4 y = y_ * ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0) * 2.0 + 1.0;\n  vec4 s1 = floor(b1) * 2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  // Normalise gradients\n  vec4 norm =\n      lamina_noise_taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  // Mix final noise value\n  vec4 m =\n      max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n  m = m * m;\n  return lamina_normalize(42.0 *\n         dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3))));\n}\n  \n  \n`;\n\nclass LayerMaterial extends ShaderMaterial {\n  static constructShader(layers = []) {\n    const uniforms = {};\n    const variables = {\n      vert: '',\n      frag: ''\n    };\n    const body = {\n      vert: '',\n      frag: ''\n    };\n    layers == null ? void 0 : layers.forEach(layer => {\n      variables.frag += layer.getFragmentVariables() + ' \\n';\n      variables.vert += layer.getVertexVariables() + ' \\n';\n      Object.keys(layer.uniforms).forEach(key => uniforms[key] = layer.uniforms[key]);\n      body.frag += layer.getFragmentBody('sc_finalColor') + ' \\n';\n      body.vert += layer.getVertexBody('') + ' \\n';\n    });\n    return {\n      uniforms,\n      vertexShader: `\n\n    ${variables.vert}\n    void main() {\n      ${body.vert}\n      vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\n      gl_Position = projectionMatrix * modelViewPosition;\n    }\n    `,\n      fragmentShader: `\n      ${HelperChunk}\n      ${NoiseChunk}\n    ${BlendModesChunk}\n    ${variables.frag}\n    void main() {\n      vec4 sc_finalColor = vec4(vec3(1.), 1.);\n      ${body.frag}\n      gl_FragColor = sc_finalColor;\n      #include <tonemapping_fragment>\n      #include <encodings_fragment>\n      #include <fog_fragment>\n      #include <premultiplied_alpha_fragment>\n      #include <dithering_fragment>\n    }\n    `\n    };\n  }\n\n  constructor(props) {\n    super(props);\n    this.layers = [];\n\n    if (props && props.layers && props.layers.length) {\n      this.layers = props.layers;\n      this.update();\n    }\n  }\n\n  update() {\n    if (this.layers.length) {\n      Object.assign(this, LayerMaterial.constructShader(this.layers));\n      this.uniformsNeedUpdate = true;\n      this.needsUpdate = true;\n    }\n  }\n\n}\n\nexport { Abstract, Base, Depth, Fresnel, LayerMaterial, Noise, Normals, Texture };\n"],
  "mappings": "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",
  "names": []
}
