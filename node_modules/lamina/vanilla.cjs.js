'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var three = require('three');

const BlendModes = {
  normal: 1,
  add: 2,
  subtract: 3,
  multiply: 4,
  addsub: 5,
  lighten: 6,
  darken: 7,
  switch: 8,
  divide: 9,
  overlay: 10,
  screen: 11,
  softlight: 12
};
const NoiseTypes = {
  white: 1,
  perlin: 2,
  simplex: 3
};
const MappingTypes = {
  uv: 1,
  local: 2,
  world: 3
};

class Abstract {
  static genID() {
    return three.MathUtils.generateUUID().replaceAll('-', '_');
  }

  getBlendMode(type, a, b) {
    if (type === BlendModes['normal']) return `sc_copy(${a}, ${b})`;else if (type === BlendModes['add']) return `sc_add(${a}, ${b})`;else if (type === BlendModes['subtract']) return `sc_subtract(${a}, ${b})`;else if (type === BlendModes['multiply']) return `sc_multiply(${a}, ${b})`;else if (type === BlendModes['addsub']) return `sc_addSub(${a}, ${b})`;else if (type === BlendModes['lighten']) return `sc_lighten(${a}, ${b})`;else if (type === BlendModes['darken']) return `sc_darken(${a}, ${b})`;else if (type === BlendModes['divide']) return `sc_divide(${a}, ${b})`;else if (type === BlendModes['overlay']) return `sc_overlay(${a}, ${b})`;else if (type === BlendModes['screen']) return `sc_screen(${a}, ${b})`;else if (type === BlendModes['softlight']) return `sc_softLight(${a}, ${b})`;else if (type === BlendModes['switch']) return `sc_switch(${a}, ${b})`;
  }

  getVertexVariables() {
    return '';
  }

  getVertexBody(e) {
    return '';
  }

}

class Base extends Abstract {
  constructor(props) {
    super();
    this.name = 'Base';
    this.mode = 'normal';
    this.uuid = Abstract.genID();
    const {
      color,
      alpha,
      mode
    } = props || {};
    this.uniforms = {
      [`u_${this.uuid}_color`]: {
        value: new three.Color(color != null ? color : '#ffffff')
      },
      [`u_${this.uuid}_alpha`]: {
        value: alpha != null ? alpha : 1
      }
    };
    this.mode = mode || 'normal';
  }

  getFragmentVariables() {
    return `    
    uniform float u_${this.uuid}_alpha;
    uniform vec3 u_${this.uuid}_color;
`;
  }

  getFragmentBody(e) {
    return `    
      ${e} = ${this.getBlendMode(BlendModes[this.mode], e, `vec4(u_${this.uuid}_color, u_${this.uuid}_alpha)`)};
  `;
  }

  set color(v) {
    this.uniforms[`u_${this.uuid}_color`].value = new three.Color(v);
  }

  get color() {
    return this.uniforms[`u_${this.uuid}_color`].value;
  }

  set alpha(v) {
    this.uniforms[`u_${this.uuid}_alpha`].value = v;
  }

  get alpha() {
    return this.uniforms[`u_${this.uuid}_alpha`].value;
  }

}

class Depth extends Abstract {
  constructor(props) {
    super();
    this.name = 'Depth';
    this.mode = 'normal';
    this.uuid = Abstract.genID();
    const {
      alpha,
      mode,
      colorA,
      colorB,
      near,
      far,
      origin,
      isVector
    } = props || {};
    this.uniforms = {
      [`u_${this.uuid}_alpha`]: {
        value: alpha != null ? alpha : 1
      },
      [`u_${this.uuid}_near`]: {
        value: near != null ? near : 700
      },
      [`u_${this.uuid}_far`]: {
        value: far != null ? far : 1e7
      },
      [`u_${this.uuid}_origin`]: {
        value: origin != null ? origin : new three.Vector3(0, 0, 0)
      },
      [`u_${this.uuid}_colorA`]: {
        value: new three.Color(colorA != null ? colorA : '#ffffff')
      },
      [`u_${this.uuid}_colorB`]: {
        value: new three.Color(colorB != null ? colorB : '#ffffff')
      },
      [`u_${this.uuid}_isVector`]: {
        value: isVector != null ? isVector : true
      }
    };
    this.mode = mode || 'normal';
  }

  getVertexVariables() {
    return (
      /* glsl */
      `
    varying vec3 v_${this.uuid}_worldPosition;
    `
    );
  }

  getVertexBody(e) {
    return (
      /* glsl */
      `
    v_${this.uuid}_worldPosition = vec3(vec4(position, 1.0) * modelMatrix);
    `
    );
  }

  getFragmentVariables() {
    return (
      /* glsl */
      `    
    uniform float u_${this.uuid}_alpha;
    uniform float u_${this.uuid}_near;
    uniform float u_${this.uuid}_far;
    uniform float u_${this.uuid}_isVector;
    uniform vec3 u_${this.uuid}_origin;
    uniform vec3 u_${this.uuid}_colorA;
    uniform vec3 u_${this.uuid}_colorB;

    varying vec3 v_${this.uuid}_worldPosition;
`
    );
  }

  getFragmentBody(e) {
    return (
      /* glsl */
      `    
     
      vec3 f_${this.uuid}_base = ( u_${this.uuid}_isVector > 0.5 ) ?  u_${this.uuid}_origin : cameraPosition;
      float f_${this.uuid}_dist = length( v_${this.uuid}_worldPosition.xyz - f_${this.uuid}_base );
      float f_${this.uuid}_dep = ( f_${this.uuid}_dist - u_${this.uuid}_near ) / ( u_${this.uuid}_far - u_${this.uuid}_near );

      vec3 f_${this.uuid}_depth =  mix( u_${this.uuid}_colorB, u_${this.uuid}_colorA, 1.0 - clamp( f_${this.uuid}_dep, 0., 1. ) );

      ${e} = ${this.getBlendMode(BlendModes[this.mode], e, `vec4(f_${this.uuid}_depth, u_${this.uuid}_alpha)`)};
  `
    );
  }

  set alpha(v) {
    this.uniforms[`u_${this.uuid}_alpha`].value = v;
  }

  get alpha() {
    return this.uniforms[`u_${this.uuid}_alpha`].value;
  }

  set near(v) {
    this.uniforms[`u_${this.uuid}_near`].value = v;
  }

  get near() {
    return this.uniforms[`u_${this.uuid}_near`].value;
  }

  set far(v) {
    this.uniforms[`u_${this.uuid}_far`].value = v;
  }

  get far() {
    return this.uniforms[`u_${this.uuid}_far`].value;
  }

  set origin(v) {
    this.uniforms[`u_${this.uuid}_origin`].value = v;
  }

  get origin() {
    return this.uniforms[`u_${this.uuid}_origin`].value;
  }

  set colorA(v) {
    this.uniforms[`u_${this.uuid}_colorA`].value = new three.Color(v);
  }

  get colorA() {
    return this.uniforms[`u_${this.uuid}_colorA`].value;
  }

  set colorB(v) {
    this.uniforms[`u_${this.uuid}_colorB`].value = new three.Color(v);
  }

  get colorB() {
    return this.uniforms[`u_${this.uuid}_colorB`].value;
  }

  set isVector(v) {
    this.uniforms[`u_${this.uuid}_isVector`].value = v;
  }

  get isVector() {
    return this.uniforms[`u_${this.uuid}_isVector`].value;
  }

}

class Fresnel extends Abstract {
  constructor(props) {
    super();
    this.name = 'Fresnel';
    this.mode = 'normal';
    this.uuid = Abstract.genID();
    const {
      alpha,
      mode,
      color,
      bias,
      intensity,
      power
    } = props || {};
    this.uniforms = {
      [`u_${this.uuid}_alpha`]: {
        value: alpha != null ? alpha : 1
      },
      [`u_${this.uuid}_color`]: {
        value: new three.Color(color != null ? color : '#ffffff')
      },
      [`u_${this.uuid}_bias`]: {
        value: bias != null ? bias : 0
      },
      [`u_${this.uuid}_intensity`]: {
        value: intensity != null ? intensity : 1
      },
      [`u_${this.uuid}_power`]: {
        value: power != null ? power : 2
      }
    };
    this.mode = mode || 'normal';
  }

  getVertexVariables() {
    return (
      /* glsl */
      `
    varying vec3 v_${this.uuid}_worldPosition;
    varying vec3 v_${this.uuid}_worldNormal;
    `
    );
  }

  getVertexBody(e) {
    return (
      /* glsl */
      `
    v_${this.uuid}_worldPosition = normalize(vec3(modelViewMatrix * vec4(position, 1.0)).xyz);
    v_${this.uuid}_worldNormal = normalize(normalMatrix * normal);
    `
    );
  }

  getFragmentVariables() {
    return (
      /* glsl */
      `    
    uniform float u_${this.uuid}_alpha;
    uniform vec3 u_${this.uuid}_color;
    uniform float u_${this.uuid}_bias;
    uniform float u_${this.uuid}_intensity;
    uniform float u_${this.uuid}_power;
    uniform float u_${this.uuid}_factor;

    varying vec3 v_${this.uuid}_worldPosition;
    varying vec3 v_${this.uuid}_worldNormal;
`
    );
  }

  getFragmentBody(e) {
    return (
      /* glsl */
      `    
      float f_${this.uuid}_a = ( 1.0 - -min(dot(v_${this.uuid}_worldPosition, normalize(v_${this.uuid}_worldNormal) ), 0.0) );
      float f_${this.uuid}_fresnel = u_${this.uuid}_bias + (u_${this.uuid}_intensity * pow(f_${this.uuid}_a, u_${this.uuid}_power));

      ${e} = ${this.getBlendMode(BlendModes[this.mode], e, `vec4(u_${this.uuid}_color * f_${this.uuid}_fresnel, u_${this.uuid}_alpha)`)};
  `
    );
  }

  set alpha(v) {
    this.uniforms[`u_${this.uuid}_alpha`].value = v;
  }

  get alpha() {
    return this.uniforms[`u_${this.uuid}_alpha`].value;
  }

  set color(v) {
    this.uniforms[`u_${this.uuid}_color`].value = new three.Color(v);
  }

  get color() {
    return this.uniforms[`u_${this.uuid}_color`].value;
  }

  set bias(v) {
    this.uniforms[`u_${this.uuid}_bias`].value = v;
  }

  get bias() {
    return this.uniforms[`u_${this.uuid}_bias`].value;
  }

  set intensity(v) {
    this.uniforms[`u_${this.uuid}_intensity`].value = v;
  }

  get intensity() {
    return this.uniforms[`u_${this.uuid}_intensity`].value;
  }

  set power(v) {
    this.uniforms[`u_${this.uuid}_power`].value = v;
  }

  get power() {
    return this.uniforms[`u_${this.uuid}_power`].value;
  }

}

class Noise extends Abstract {
  constructor(props) {
    super();
    this.name = 'Noise';
    this.mode = 'normal';
    this.type = 'perlin';
    this.mapping = 'uv';
    this.uuid = Abstract.genID();
    const {
      alpha,
      mode,
      scale,
      colorA,
      colorB,
      type,
      mapping
    } = props || {};
    this.uniforms = {
      [`u_${this.uuid}_alpha`]: {
        value: alpha != null ? alpha : 1
      },
      [`u_${this.uuid}_scale`]: {
        value: scale != null ? scale : 1
      },
      [`u_${this.uuid}_colorA`]: {
        value: new three.Color(colorA != null ? colorA : '#ffffff')
      },
      [`u_${this.uuid}_colorB`]: {
        value: new three.Color(colorB != null ? colorB : '#000000')
      }
    };
    this.mode = mode || 'normal';
    this.type = type || 'perlin';
    this.mapping = mapping || 'uv';
  }

  getMapping() {
    switch (MappingTypes[this.mapping]) {
      case MappingTypes.uv:
        return `vec3(uv, 0.)`;

      case MappingTypes.local:
        return `position`;

      case MappingTypes.world:
        return `
        (modelMatrix * vec4(position,1.0)).xyz;
        `;
    }
  }

  getNoise(e) {
    switch (NoiseTypes[this.type]) {
      case NoiseTypes.white:
        return `lamina_noise_white(${e})`;

      case NoiseTypes.perlin:
        return `lamina_noise_perlin(${e})`;

      case NoiseTypes.simplex:
        return `lamina_noise_simplex(${e})`;
    }
  }

  getVertexVariables() {
    return (
      /* glsl */
      `
    varying vec3 v_${this.uuid}_position;
    `
    );
  }

  getVertexBody(e) {
    return (
      /* glsl */
      `
    v_${this.uuid}_position = ${this.getMapping()};
    `
    );
  }

  getFragmentVariables() {
    return (
      /* glsl */
      `    
    uniform float u_${this.uuid}_alpha;
    uniform vec3 u_${this.uuid}_colorA;
    uniform vec3 u_${this.uuid}_colorB;
    uniform float u_${this.uuid}_scale;
    varying vec3 v_${this.uuid}_position;
`
    );
  }

  getFragmentBody(e) {
    return (
      /* glsl */
      `    
      float f_${this.uuid}_noise = ${this.getNoise(`v_${this.uuid}_position * u_${this.uuid}_scale`)};
      vec3 f_${this.uuid}_noiseColor = mix(u_${this.uuid}_colorA, u_${this.uuid}_colorB, f_${this.uuid}_noise);

      ${e} = ${this.getBlendMode(BlendModes[this.mode], e, `vec4(f_${this.uuid}_noiseColor, u_${this.uuid}_alpha)`)};
  `
    );
  }

  set alpha(v) {
    this.uniforms[`u_${this.uuid}_alpha`].value = v;
  }

  get alpha() {
    return this.uniforms[`u_${this.uuid}_alpha`].value;
  }

  set colorA(v) {
    this.uniforms[`u_${this.uuid}_colorA`].value = new three.Color(v);
  }

  get colorA() {
    return this.uniforms[`u_${this.uuid}_colorA`].value;
  }

  set colorB(v) {
    this.uniforms[`u_${this.uuid}_colorB`].value = new three.Color(v);
  }

  get colorB() {
    return this.uniforms[`u_${this.uuid}_colorB`].value;
  }

  set scale(v) {
    this.uniforms[`u_${this.uuid}_scale`].value = v;
  }

  get scale() {
    return this.uniforms[`u_${this.uuid}_scale`].value;
  }

}

class Normals extends Abstract {
  constructor(props) {
    super();
    this.name = 'Normals';
    this.mode = 'normal';
    this.uuid = Abstract.genID();
    const {
      alpha,
      mode,
      direction
    } = props || {};
    this.uniforms = {
      [`u_${this.uuid}_alpha`]: {
        value: alpha != null ? alpha : 1
      },
      [`u_${this.uuid}_direction`]: {
        value: direction
      }
    };
    this.mode = mode || 'normal';
  }

  getVertexVariables() {
    return (
      /* glsl */
      `
    varying vec3 v_${this.uuid}_normals;
    `
    );
  }

  getVertexBody(e) {
    return (
      /* glsl */
      `
    v_${this.uuid}_normals = normal;
    `
    );
  }

  getFragmentVariables() {
    return (
      /* glsl */
      `    
    uniform float u_${this.uuid}_alpha;
    uniform vec3 u_${this.uuid}_color;
    uniform vec3 u_${this.uuid}_direction;

    varying vec3 v_${this.uuid}_normals;
`
    );
  }

  getFragmentBody(e) {
    return (
      /* glsl */
      `    
      vec3 f_${this.uuid}_normalColor = vec3(1.);
      f_${this.uuid}_normalColor.x = v_${this.uuid}_normals.x * u_${this.uuid}_direction.x;
      f_${this.uuid}_normalColor.y = v_${this.uuid}_normals.y * u_${this.uuid}_direction.y;
      f_${this.uuid}_normalColor.z = v_${this.uuid}_normals.z * u_${this.uuid}_direction.z;

      ${e} = ${this.getBlendMode(BlendModes[this.mode], e, `vec4(f_${this.uuid}_normalColor, u_${this.uuid}_alpha)`)};
  `
    );
  }

  set alpha(v) {
    this.uniforms[`u_${this.uuid}_alpha`].value = v;
  }

  get alpha() {
    return this.uniforms[`u_${this.uuid}_alpha`].value;
  }

  set color(v) {
    this.uniforms[`u_${this.uuid}_color`].value = new three.Color(v);
  }

  get color() {
    return this.uniforms[`u_${this.uuid}_color`].value;
  }

  set direction(v) {
    this.uniforms[`u_${this.uuid}_direction`].value = v;
  }

  get direction() {
    return this.uniforms[`u_${this.uuid}_direction`].value;
  }

}

class Texture extends Abstract {
  constructor(props) {
    super();
    this.name = 'Texture';
    this.mode = 'texture';
    this.uuid = Abstract.genID();
    const {
      alpha,
      mode,
      map
    } = props || {};
    this.uniforms = {
      [`u_${this.uuid}_alpha`]: {
        value: alpha != null ? alpha : 1
      },
      [`u_${this.uuid}_map`]: {
        value: map
      }
    };
    this.mode = mode || 'normal';
  }

  getVertexVariables() {
    return (
      /* glsl */
      `
    varying vec2 v_${this.uuid}_uv;
    `
    );
  }

  getVertexBody(e) {
    return (
      /* glsl */
      `
    v_${this.uuid}_uv = uv;
    `
    );
  }

  getFragmentVariables() {
    return (
      /* glsl */
      `    
    uniform float u_${this.uuid}_alpha;
    uniform sampler2D u_${this.uuid}_map;

    varying vec2 v_${this.uuid}_uv;
`
    );
  }

  getFragmentBody(e) {
    return (
      /* glsl */
      `    
      vec4 f_${this.uuid}_texture = texture2D(u_${this.uuid}_map, v_${this.uuid}_uv);

      ${e} = ${this.getBlendMode(BlendModes[this.mode], e, `vec4(f_${this.uuid}_texture.xyz, f_${this.uuid}_texture.a * u_${this.uuid}_alpha)`)};
  `
    );
  }

  set alpha(v) {
    this.uniforms[`u_${this.uuid}_alpha`].value = v;
  }

  get alpha() {
    return this.uniforms[`u_${this.uuid}_alpha`].value;
  }

  set map(v) {
    this.uniforms[`u_${this.uuid}_map`].value = v;
  }

  get map() {
    return this.uniforms[`u_${this.uuid}_map`].value;
  }

}

var HelperChunk = /* glsl */
`

float lamina_map(float value, float min1, float max1, float min2, float max2) {
  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

float lamina_normalize(float v) { return lamina_map(v, -1.0, 1.0, 0.0, 1.0); }
`;

var BlendModesChunk = /* glsl */
`
// SC: Blend modes definitions **********

float sc_softLight(float f, float b) {
  return (f < 0.5)
             ? b - (1.0 - 2.0 * f) * b * (1.0 - b)
             : (b < 0.25)
                   ? b + (2.0 * f - 1.0) * b * ((16.0 * b - 12.0) * b + 3.0)
                   : b + (2.0 * f - 1.0) * (sqrt(b) - b);
}

vec4 sc_softLight(vec4 b, vec4 f) {
  vec4 result;
  result.x = sc_softLight(f.x, b.x);
  result.y = sc_softLight(f.y, b.y);
  result.z = sc_softLight(f.z, b.z);
  result.a = sc_softLight(f.a, b.a);
  
  return result;
}

vec4 sc_screen(vec4 f, vec4 b) {
  vec4 result;

  result = 1.0 - (1.0 - f) * (1.0 - b);
  result = mix(f, result, b.a);

  return result;
}

float sc_overlay(float f, float b) {
  return (b < 0.5) ? 2.0 * f * b : 1.0 - 2.0 * (1.0 - f) * (1.0 - b);
}

vec4 sc_overlay(vec4 b, vec4 f) {
  vec4 result;
  result.x = sc_overlay(f.x, b.x);
  result.y = sc_overlay(f.y, b.y);
  result.z = sc_overlay(f.z, b.z);
  result.a = sc_overlay(f.a, b.a);


  return result;
}

vec4 sc_divide(vec4 f, vec4 b) {
  vec4 result = vec4(0.0);
  result = b / f;
  return result;
}

vec4 sc_switch(vec4 f, vec4 b) {
  vec4 result = vec4(0.0);
  result = max((f * b.a), (b * (1.0 - b.a)));
  return result;
}

vec4 sc_darken(vec4 f, vec4 b) {
  vec4 result = vec4(0.0);
  result = mix(f, min(f, b), b.a);
  return result;
}

vec4 sc_lighten(vec4 f, vec4 b) {
  vec4 result = vec4(0.0);
  result = mix(f, max(f, b), b.a);
  return result;
}

float sc_addSub(float f, float b) {
  return f > 0.5 ? f + b : b - f;
}
vec4 sc_addSub(vec4 f, vec4 b) {
  vec4 result = vec4(0.0);

  result.r = sc_addSub(f.r, b.r * b.a);
  result.g = sc_addSub(f.g, b.g * b.a);
  result.b = sc_addSub(f.b, b.b* b.a ) ;
  result.a = sc_addSub(f.a, b.a);

  return result;
}

vec4 sc_multiply(vec4 f, vec4 b) {
  vec4 result = vec4(0.0);

  result = mix(f, b * f, b.a);
  result.a = f.a + b.a * (1.0 - f.a);

  return result;
}

vec4 sc_subtract(vec4 f, vec4 b) {
  vec4 result = vec4(0.0);

  result = f - b * b.a;
  result.a = f.a + b.a * (1.0 - f.a);

  return result;
}

vec4 sc_add(vec4 f, vec4 b) {
  vec4 result = vec4(0.0);

  result = f + b * (b.a);
  result.a = f.a + b.a * (1.0 - f.a);

  return result;
}

vec4 sc_copy(vec4 b, vec4 f) {
  vec4 result = vec4(0.0);

  result.a = f.a + b.a * (1.0 - f.a);
  result.rgb = ((f.rgb * f.a) + (b.rgb * b.a) * (1.0 - f.a));

  return result;
}

`; // ************************************

var NoiseChunk = /* glsl */
`

// From: https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83
// Huge thanks to the creators of these algorithms

float lamina_noise_mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}
vec4 lamina_noise_mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}
vec4 lamina_noise_perm(vec4 x){return lamina_noise_mod289(((x * 34.0) + 1.0) * x);}
vec4 lamina_noise_permute(vec4 x) { return mod(((x * 34.0) + 1.0) * x, 289.0); }
vec4 lamina_noise_taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }


float lamina_noise_white(vec2 p) {
  return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) *
               (0.1 + abs(sin(p.y * 13.0 + p.x))));
}

float lamina_noise_white(vec3 p) {
  return lamina_noise_white(p.xy);
}


vec3 lamina_noise_fade(vec3 t) { return t * t * t * (t * (t * 6.0 - 15.0) + 10.0); }

float lamina_noise_perlin(vec3 P) {
  vec3 Pi0 = floor(P);        // Integer part for indexing
  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
  Pi0 = mod(Pi0, 289.0);
  Pi1 = mod(Pi1, 289.0);
  vec3 Pf0 = fract(P);        // Fractional part for interpolation
  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
  vec4 iy = vec4(Pi0.yy, Pi1.yy);
  vec4 iz0 = Pi0.zzzz;
  vec4 iz1 = Pi1.zzzz;

  vec4 ixy = lamina_noise_permute(lamina_noise_permute(ix) + iy);
  vec4 ixy0 = lamina_noise_permute(ixy + iz0);
  vec4 ixy1 = lamina_noise_permute(ixy + iz1);

  vec4 gx0 = ixy0 / 7.0;
  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;
  gx0 = fract(gx0);
  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
  vec4 sz0 = step(gz0, vec4(0.0));
  gx0 -= sz0 * (step(0.0, gx0) - 0.5);
  gy0 -= sz0 * (step(0.0, gy0) - 0.5);

  vec4 gx1 = ixy1 / 7.0;
  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;
  gx1 = fract(gx1);
  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
  vec4 sz1 = step(gz1, vec4(0.0));
  gx1 -= sz1 * (step(0.0, gx1) - 0.5);
  gy1 -= sz1 * (step(0.0, gy1) - 0.5);

  vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);
  vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);
  vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);
  vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);
  vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);
  vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);
  vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);
  vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);

  vec4 norm0 = lamina_noise_taylorInvSqrt(
      vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
  g000 *= norm0.x;
  g010 *= norm0.y;
  g100 *= norm0.z;
  g110 *= norm0.w;
  vec4 norm1 = lamina_noise_taylorInvSqrt(
      vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
  g001 *= norm1.x;
  g011 *= norm1.y;
  g101 *= norm1.z;
  g111 *= norm1.w;

  float n000 = dot(g000, Pf0);
  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
  float n111 = dot(g111, Pf1);

  vec3 fade_xyz = lamina_noise_fade(Pf0);
  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111),
                 fade_xyz.z);
  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
  return lamina_normalize(2.2 * n_xyz);
}

float lamina_noise_simplex(vec3 v) {
  const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);
  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);

  // First corner
  vec3 i = floor(v + dot(v, C.yyy));
  vec3 x0 = v - i + dot(i, C.xxx);

  // Other corners
  vec3 g = step(x0.yzx, x0.xyz);
  vec3 l = 1.0 - g;
  vec3 i1 = min(g.xyz, l.zxy);
  vec3 i2 = max(g.xyz, l.zxy);

  //  x0 = x0 - 0. + 0.0 * C
  vec3 x1 = x0 - i1 + 1.0 * C.xxx;
  vec3 x2 = x0 - i2 + 2.0 * C.xxx;
  vec3 x3 = x0 - 1. + 3.0 * C.xxx;

  // Permutations
  i = mod(i, 289.0);
  vec4 p = lamina_noise_permute(lamina_noise_permute(lamina_noise_permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y +
                             vec4(0.0, i1.y, i2.y, 1.0)) +
                    i.x + vec4(0.0, i1.x, i2.x, 1.0));

  // Gradients
  // ( N*N points uniformly over a square, mapped onto an octahedron.)
  float n_ = 1.0 / 7.0; // N=7
  vec3 ns = n_ * D.wyz - D.xzx;

  vec4 j = p - 49.0 * floor(p * ns.z * ns.z); //  mod(p,N*N)

  vec4 x_ = floor(j * ns.z);
  vec4 y_ = floor(j - 7.0 * x_); // mod(j,N)

  vec4 x = x_ * ns.x + ns.yyyy;
  vec4 y = y_ * ns.x + ns.yyyy;
  vec4 h = 1.0 - abs(x) - abs(y);

  vec4 b0 = vec4(x.xy, y.xy);
  vec4 b1 = vec4(x.zw, y.zw);

  vec4 s0 = floor(b0) * 2.0 + 1.0;
  vec4 s1 = floor(b1) * 2.0 + 1.0;
  vec4 sh = -step(h, vec4(0.0));

  vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
  vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;

  vec3 p0 = vec3(a0.xy, h.x);
  vec3 p1 = vec3(a0.zw, h.y);
  vec3 p2 = vec3(a1.xy, h.z);
  vec3 p3 = vec3(a1.zw, h.w);

  // Normalise gradients
  vec4 norm =
      lamina_noise_taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
  p0 *= norm.x;
  p1 *= norm.y;
  p2 *= norm.z;
  p3 *= norm.w;

  // Mix final noise value
  vec4 m =
      max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);
  m = m * m;
  return lamina_normalize(42.0 *
         dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3))));
}
  
  
`;

class LayerMaterial extends three.ShaderMaterial {
  static constructShader(layers = []) {
    const uniforms = {};
    const variables = {
      vert: '',
      frag: ''
    };
    const body = {
      vert: '',
      frag: ''
    };
    layers == null ? void 0 : layers.forEach(layer => {
      variables.frag += layer.getFragmentVariables() + ' \n';
      variables.vert += layer.getVertexVariables() + ' \n';
      Object.keys(layer.uniforms).forEach(key => uniforms[key] = layer.uniforms[key]);
      body.frag += layer.getFragmentBody('sc_finalColor') + ' \n';
      body.vert += layer.getVertexBody('') + ' \n';
    });
    return {
      uniforms,
      vertexShader: `

    ${variables.vert}
    void main() {
      ${body.vert}
      vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);
      gl_Position = projectionMatrix * modelViewPosition;
    }
    `,
      fragmentShader: `
      ${HelperChunk}
      ${NoiseChunk}
    ${BlendModesChunk}
    ${variables.frag}
    void main() {
      vec4 sc_finalColor = vec4(vec3(1.), 1.);
      ${body.frag}
      gl_FragColor = sc_finalColor;
      #include <tonemapping_fragment>
      #include <encodings_fragment>
      #include <fog_fragment>
      #include <premultiplied_alpha_fragment>
      #include <dithering_fragment>
    }
    `
    };
  }

  constructor(props) {
    super(props);
    this.layers = [];

    if (props && props.layers && props.layers.length) {
      this.layers = props.layers;
      this.update();
    }
  }

  update() {
    if (this.layers.length) {
      Object.assign(this, LayerMaterial.constructShader(this.layers));
      this.uniformsNeedUpdate = true;
      this.needsUpdate = true;
    }
  }

}

exports.Abstract = Abstract;
exports.Base = Base;
exports.Depth = Depth;
exports.Fresnel = Fresnel;
exports.LayerMaterial = LayerMaterial;
exports.Noise = Noise;
exports.Normals = Normals;
exports.Texture = Texture;
